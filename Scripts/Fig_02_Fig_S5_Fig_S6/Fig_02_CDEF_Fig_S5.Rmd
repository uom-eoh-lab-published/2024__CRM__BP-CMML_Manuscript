---
title: "Figure 02 - Panels CDEF + Fig S5"
output: 
  rmdformats::robobook:
    lightbox: true
    fig_caption: true
---

```{=html}
<style type="text/css">
  body{
  font-size: 10pt;
}
</style>
```

# 1) Setup

## - Defining work directory

In this section, we define the working directory for the R Markdown document.

```{r setup, include=TRUE}
# Get the path of the current script
# Then get the parent directory of the parent directory of the parent directory
local_wd_folder <- dirname(dirname(dirname(rstudioapi::getSourceEditorContext()$path)))

# Set the root directory for knitr to the local working directory
knitr::opts_knit$set(root.dir = local_wd_folder)
```

## - Defining input data and output directories

Here, we define the directories for input data and output files.

```{r}
# Get the directory of the current script
script_folder <- dirname(rstudioapi::getSourceEditorContext()$path)

# Define the data folder and output folder
data_folder <- './Data'
#results_folder <- './Results'
figures_folder <- './Figures'

dir.create(path = paste(data_folder, '/RNASeq/InHouse/DESeq2/DEGs_Comparisons', sep = ''), 
           showWarnings = F)

dir.create(paste(data_folder, '/RNASeq/InHouse/DESeq2/DEGs_Comparisons/BP-CMML_vs_Control', sep = ''), 
           showWarnings = F)
```

## - Setting seed

Setting a seed ensures that any random processes are reproducible.

```{r}
# Set a seed for reproducibility
set.seed(123)
```

## - Packages installation (optional)

In this section, we ensure that all necessary packages are installed.

```{r}
# Ensure BiocManager is available for installation of Bioconductor packages
if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
BiocManager::install(version = "3.18", ask = FALSE)

# Define a list of required packages used in this script
packages_required <- c("ComplexHeatmap", "stringr", "tximport", "DESeq2", "tidyverse", 
                       "plotly", "dplyr", "R.utils", "GenomicFeatures", "ashr",
                       "apeglm", "EnhancedVolcano", "IHW", "circlize", "Matrix",
                        "unikn", "RColorBrewer", "yarrr", "scales", "ggsci")

# Identify any required packages that are not installed
packages_uninstalled <- packages_required[!(packages_required %in% installed.packages()[,"Package"])]

# Install any uninstalled packages
if(length(packages_uninstalled)) BiocManager::install(packages_uninstalled, ask = FALSE)
```

## - Loading packages

Here, we load the necessary packages for our analysis.

```{r message=FALSE, warning=FALSE}
library(stringr, quietly = TRUE)
library(reticulate)
library(ComplexHeatmap, quietly = TRUE)
library(EnhancedVolcano)
library(GenomicFeatures)
library(circlize)
library(tidyverse)
library(R.utils)
library(tximport)
library(DESeq2)
library(dplyr)
library(IHW)
library(ashr)
library(apeglm)
library(plotly)
```

```{r}
# To create a conda environment first install either miniconda3 or anaconda3 on your OS
# conda create --name BPCMML python-kaleido plotly -c conda-forge
reticulate::use_condaenv("BPCMML")
```

## - Loading palettes

In this section, we load additional color palettes and define some custom ones.

```{r message=FALSE, warning=FALSE}
# Load additional colour palette packages
library(unikn, quietly = TRUE)
library(RColorBrewer, quietly = TRUE)
library(yarrr, quietly = TRUE)
library(scales, quietly = TRUE)
library(ggsci, quietly = TRUE)

# Define a set of custom color palettes from the unikn package
mix_1 <- usecol(pal = c(Karpfenblau, "white", Peach), n = 15)
mix_2 <- usecol(pal = c(rev(pal_seeblau), "white", pal_pinky))
mix_3 <- usecol(pal = c(rev(pal_bordeaux), "white", pal_petrol), n = 15)

# Display the custom palettes
seecol(list(mix_1, mix_2, mix_3), col_brd = "white", lwd_brd = 4, title = "Comparing palettes mixed from unikn colors", pal_names = c("mix_1", "mix_2", "mix_3"))

# Define a second set of custom palettes from the RColorBrewer and yarrr packages
brew_mix <- usecol(c(rev(brewer.pal(n = 4, name = "Reds")), "white", brewer.pal(n = 4, name = "Blues")), n = 13)
brew_ext <- usecol(brewer.pal(n = 11, name = "Spectral"), n = 12)
yarrr_mix <- usecol(c(piratepal("nemo"), piratepal("bugs")))
yarrr_mod <- usecol(c(piratepal("ipod")), n = 9)

# Display the second set of custom palettes
seecol(pal = list(brew_mix, brew_ext, yarrr_mix, yarrr_mod), col_brd = "white", lwd_brd = 2, title = "Using usecol() and seecol() to mix and modify palettes", pal_names = c("brew_mix", "brew_ext", "yarrr_mix", "yarrr_mod"))

# Define additional custom palettes from the scales package
natjournals_palette <- pal_npg("nrc")(10)
```

## - Log Session Info

Finally, we log the session information for reproducibility.

```{r message=TRUE, warning=TRUE}
# Write the session information to a text file
writeLines(capture.output(sessionInfo()), file.path(script_folder, 'Fig_02_CDEF_Fig_S5_SessionInfo.txt'))

# Print the session information
sessionInfo()
```

# 2) Loading input files

## - Loading gene annotation files

We use the following code to download a gene annotation file, convert it into a SQLite database for genomic analysis, or load the existing database if it's already present.

### - Load check or creation of sqlite file

```{r}
# Define the path to the SQLite database
txdb.filename <- paste(data_folder, "/Resources/RNASeq/Annotation_files/GENCODE_v42.annotation.sqlite", sep = '')

# Check if the SQLite database already exists
if (file.exists(txdb.filename)) {
  
  # Print a message indicating that the database already exists and is being loaded
  print(sprintf('File %s already exist! Now Loading...',txdb.filename))
  
  # Load the SQLite database
  txdb <- loadDb(txdb.filename)
  
} else {

  # Define the URL of the GTF file to download
  url <- "https://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_42/gencode.v42.annotation.gtf.gz"
  
  dir.create(paste(data_folder, "/Resources/RNASeq/Annotation_files", sep = ''), 
             showWarnings = F)
  
  # Define the local path where the GTF file will be saved
  destfile <- paste(data_folder, "/Resources/RNASeq/Annotation_files/GENCODE_v42.annotation.gtf.gz", sep = '')
  
  # Download the GTF file
  download.file(url, destfile)
  
  # Define the path of the decompressed GTF file
  gtf <- paste(data_folder, "/Resources/RNASeq/Annotation_files/GENCODE_v42.annotation.gtf", sep = '')
  
  # If the decompressed GTF file already exists, remove it
  if (file.exists(gtf)) {
    file.remove(gtf)
  }
  
  # Decompress the GTF file
  gunzip(destfile)

  # Create a TxDb object from the GTF file
  txdb <- makeTxDbFromGFF(gtf)
  
  # Save the TxDb object as a SQLite database for later use
  saveDb(txdb, txdb.filename)
  
  # Load the SQLite database
  txdb <- loadDb(txdb.filename)

  # Print a message indicating that the SQLite database has been generated
  print(sprintf('File %s has been generated!',txdb.filename))

}
```

### - Load check or creation of csv file

We use the following code to load gene metadata from a CSV file, or if it's not present, to extract it from a GTF file and create the CSV.

```{r}
# Define the path to the gene metadata CSV file
gencode_gene_info_df.filename <- paste(data_folder, "/Resources/RNASeq/Annotation_files/GENCODE_v42.gene_metadata.csv", sep = '')

# Check if the CSV file already exists
if (file.exists(gencode_gene_info_df.filename)) {
  
  # Print a message indicating that the CSV file already exists
  print(sprintf('File %s already exist! Now Loading...',gencode_gene_info_df.filename))
  
  # Load the CSV file into a dataframe
  Genes_annotation_metadata <- read.csv(paste(data_folder, '/Resources/RNASeq/Annotation_files/GENCODE_v42.gene_metadata.csv', sep = ''), header = TRUE)
  
  # Set the row names of the dataframe to the gene IDs
  rownames(Genes_annotation_metadata) <- Genes_annotation_metadata$gene_id
  
} else {
  
  # Define the path to the GTF file and the SQLite database
  gtf <- paste(data_folder, "/Resources/RNASeq/Annotation_files/GENCODE_v42.annotation.gtf", sep = '')
  txdb.filename <- paste(data_folder, "/Resources/RNASeq/Annotation_files/GENCODE_v42.annotation.sqlite", sep = '')
  
  # Load the SQLite database
  txdb <- loadDb(txdb.filename)
  
  # Load the GTF file into a dataframe
  gtf_df <- read.table(file = gtf, sep="\t", header=FALSE)
  
  # Filter the dataframe to include only rows where the third column is 'gene'
  gtf_df_genes <- gtf_df %>% dplyr::filter(V3 == 'gene')
  
  # Create an empty dataframe to store the gene metadata
  gencode_gene_info_df <- data.frame()
  
  # Create a progress bar
  pb <- txtProgressBar(min = 0, max = nrow(gtf_df_genes), style = 3)
  
  # Iterate over the rows of the filtered dataframe
  for (gene_index in 1:nrow(gtf_df_genes)) {
    
    # Update the progress bar
    setTxtProgressBar(pb, gene_index)
    
    # Extract the gene information from the ninth column of the current row
    gene_info <- gsub(";\\s+", ";", gtf_df_genes[gene_index,'V9'])
    
    # Split the gene information into items
    items <- strsplit(gene_info, ";")[[1]]
    
    # Iterate over the items and split each one on the space
    for (item in items) {
      parts <- unlist(strsplit(item, " "))
      
      # If there are exactly two parts, add them to the dataframe as a new column
      if (length(parts) == 2) {
        gencode_gene_info_df[unlist(strsplit(items[[1]], " "))[[2]],sprintf('%s',parts[1])] <- parts[2]
      }
    }
  }
  
  # Close the progress bar
  close(pb)
  
  # Write the dataframe to a CSV file
  write.csv(x = gencode_gene_info_df, file = gencode_gene_info_df.filename, row.names = F)
  
  # Print a message indicating that the CSV file has been generated
  print(sprintf('File %s has been generated! Now loading...',gencode_gene_info_df.filename))
  
  # Load the CSV file into a dataframe
  Genes_annotation_metadata <- read.csv(paste(data_folder, '/Resources/RNASeq/Annotation_files/GENCODE_v42.gene_metadata.csv', sep = ''), header = TRUE)
  
  # Set the row names of the dataframe to the gene IDs
  rownames(Genes_annotation_metadata) <- Genes_annotation_metadata$gene_id
}
```

## - Loading sample metadata files

```{r}
Samples_metadata <- read.csv(paste(data_folder, '/RNASeq/InHouse/Metadata/Samples_Metadata.csv', sep = ''), row.names = 'Patient.ID')
Samples_metadata$Condition <- factor(Samples_metadata$Condition)
Samples_metadata$Condition <- relevel(Samples_metadata$Condition, ref = "Control")
```

# 3) Importing and grouping raw counts

Here we check for the existence of a specific RDS file. If it doesn't exist, we perform gene-level summarization and save the results as CSV files.

```{r}
# Define the path to the RDS file
rds_file <- paste(data_folder, '/RNASeq/InHouse/Counts/Tximport_object.rds', sep = '')

# Check if the RDS file exists
if (!file.exists(rds_file)) {

  ## - Loading counts path
  
  STAR_Salmon_output_path <- paste(data_folder, '/RNASeq/InHouse/Counts/Raw_counts/Individual', sep = '')
  
  files <- file.path(STAR_Salmon_output_path, list.files(STAR_Salmon_output_path), "quant.sf")
  names(files) <- list.files(STAR_Salmon_output_path)
  
  ## - Gene-level summarization via tximport
  
  k <- keys(txdb, keytype = "TXNAME")
  tx2gene <- AnnotationDbi::select(txdb, k, "GENEID", "TXNAME")
  
  TXI.Genes <- tximport(files, type="salmon", tx2gene=tx2gene, 
                    txIn = TRUE, txOut = FALSE, countsFromAbundance = 'no')
  
  TXI.Genes$abundance <- TXI.Genes$abundance[,rownames(Samples_metadata)]
  TXI.Genes$counts <- TXI.Genes$counts[,rownames(Samples_metadata)]
  TXI.Genes$length <- TXI.Genes$length[,rownames(Samples_metadata)]
  
  saveRDS(TXI.Genes, file = paste(data_folder, '/RNASeq/InHouse/Counts/Tximport_object.rds', sep = ''))
  
  ## - Exporting gene-level counts and TPMs
  
  dir.create(paste(data_folder, '/RNASeq/InHouse/Counts/Raw_counts/Grouped', sep = ''), showWarnings = F)
  
  dir.create(paste(data_folder, '/RNASeq/InHouse/Counts/Processed_counts', sep = ''), showWarnings = F)
  dir.create(paste(data_folder, '/RNASeq/InHouse/Counts/Processed_counts/Grouped', sep = ''), showWarnings = F)
  
  write.csv(x = TXI.Genes$counts, file = paste(data_folder, '/RNASeq/InHouse/Counts/Raw_counts/Grouped/Tximport_raw_countmat.csv', sep = ''), row.names = TRUE, quote = FALSE)
  
  write.csv(x = TXI.Genes$abundance, file =  paste(data_folder, '/RNASeq/InHouse/Counts/Processed_counts/Grouped/Tximport_TPM_mat.csv', sep = ''), row.names = TRUE, quote = FALSE)

}
```

# 4) DESeq2 Analysis

## - Loading read and TPM matrices

This script creates a new directory named 'DESeq2' under the 'RNASeq/InHouse' directory. If the directory already exists, it doesn't show any warnings. After that, it reads an RDS file named 'Tximport_object.rds' from the 'Counts' directory under 'RNASeq/InHouse'. The data from the RDS file is stored in the TXI.Genes variable.

```{r}
# Create directory and read RDS file
dir.create(paste(data_folder, '/RNASeq/InHouse/DESeq2', sep = ''), showWarnings = F)
TXI.Genes <- readRDS(paste(data_folder, '/RNASeq/InHouse/Counts/Tximport_object.rds', sep = ''))
```

## - Create a DESeqDataSet from the Tximport object

Here we create a DESeqDataSet object from the gene-level summarization data. This object is used for differential expression analysis, with the condition (e.g., BP-CMML vs. control) as the variable of interest.

```{r}
dds <- DESeqDataSetFromTximport(
  txi = TXI.Genes, 
  colData = Samples_metadata,
  rowData = Genes_annotation_metadata[rownames(TXI.Genes$counts),], 
  design = ~ Condition
)
```

## - Filtering non-unique uninformative Ensembl.id

Here we normalize the count data, filter out rows based on the normalized counts, and then perform differential expression analysis using the DESeq2 package.

```{r}
# Estimate size factors
dds <- estimateSizeFactors(dds)

# Filter rows based on normalized counts
keep <- rowSums(counts(dds, normalized=TRUE) >= 5 ) >= 3
dds <- dds[keep,]

# Run DESeq
dds <- DESeq(dds)
```

Here we check the uniqueness of gene names in our dataset. For non-unique gene names, we keep only the row with the maximum absolute expression and remove the rest to ensure uniqueness.

```{r}
# Check uniqueness of gene names
unique_gene_names <- isUnique(rowData(dds)$gene_name)
print(table(unique_gene_names))

# Get rows with non-unique gene names
non_unique_rows <- rowData(dds)[grep(FALSE, unique_gene_names),]
df <- as.data.frame(non_unique_rows)

# Get maximum absolute value of Expression by Gene
maxabs <- with(df, aggregate(baseMean, list(gene_name=gene_name), FUN=function(x) max(abs(x))))

# Merge with original data frame
df <- merge(df, maxabs, by="gene_name")

# Get rows with maximum absolute expression
df_unique <- subset(df, abs(baseMean) == x)

# Remove duplicate genes
df_unique <- df_unique[!duplicated(df_unique$gene_name), ]
```

Here we extract unique gene IDs from our dataset and write them to a CSV file. We then verify the uniqueness of these gene IDs.

```{r}
# Get unique gene IDs
unique_genes <- c(rowData(dds)[grep(TRUE,isUnique(rowData(dds)$gene_name)),]$gene_id, df_unique$gene_id)

# Write unique genes to CSV
write.csv(x = data.frame(unique_genes), 
          file = paste(data_folder, '/RNASeq/InHouse/Counts/Processed_counts/List_unique_genes.csv', sep = ''), quote = FALSE, row.names = FALSE)

# Check uniqueness of unique genes
print(table(isUnique(unique_genes)))
```

Here we calculate the difference in the count of unique gene IDs before and after removing duplicates. We then compute the proportion of this difference relative to the total count of unique gene IDs after duplicate removal.

```{r}
# Calculate difference in uniqueness counts
diff_uniqueness <- table(isUnique(unique_genes)) - table(isUnique(rowData(dds)$gene_name))[[2]]
print(diff_uniqueness)

# Calculate proportion of difference
proportion_diff <- diff_uniqueness / table(isUnique(unique_genes))
print(proportion_diff)
```

## - Running DESeq2 with unique genes

## - Testing parametric dispersion vs local

This script performs differential expression analysis using both parametric and local fit types, and then determines the best scoring fit type based on the median absolute residuals.

```{r echo=TRUE, fig.align='center', fig.pos='H', fig.height=5, fig.width=6}
# Create DESeqDataSet and perform DESeq analysis with parametric fit
dds_parametric <- DESeqDataSetFromTximport(txi = TXI.Genes, colData = Samples_metadata, rowData = Genes_annotation_metadata[rownames(TXI.Genes$counts),], design = ~ Condition)
dds_parametric <- estimateSizeFactors(dds_parametric)
dds_parametric <- dds_parametric[unique_genes,]
dds_parametric <- DESeq(dds_parametric, fitType = "parametric")

# Calculate and plot residuals for parametric fit
Residuals_parametric <- log(mcols(dds_parametric)$dispGeneEst) - log(mcols(dds_parametric)$dispFit)
plotDispEsts(dds_parametric, main= "dispEst: Parametric")
hist(x = Residuals_parametric, xlim = c(-20,10))
Median_Absolute_Residual_parametric <- median(abs(Residuals_parametric))

# Relevel condition and get results for parametric fit
dds_parametric$Condition <- relevel(dds_parametric$Condition, ref = "Control")
res_parametric <- results(dds_parametric, contrast=c("Condition", "BP-CMML", "Control"))

# Create DESeqDataSet and perform DESeq analysis with local fit
dds_local <- DESeqDataSetFromTximport(txi = TXI.Genes, colData = Samples_metadata, rowData= Genes_annotation_metadata[rownames(TXI.Genes$counts),], design = ~ Condition)
dds_local <- estimateSizeFactors(dds_local)
dds_local <- dds_local[unique_genes,]
dds_local <- DESeq(dds_local, fitType = "local")

# Calculate and plot residuals for local fit
Residuals_local <- log(mcols(dds_local)$dispGeneEst) - log(mcols(dds_local)$dispFit)
plotDispEsts(dds_local, main= "dispEst: Local")
hist(x = Residuals_local, xlim = c(-20,10))
Median_Absolute_Residual_local <- median(abs(Residuals_local))

# Relevel condition and get results for local fit
dds_local$Condition <- relevel(dds_local$Condition, ref = "Control")
res_local <- results(dds_local, contrast=c("Condition", "BP-CMML", "Control"))

# Determine best scoring fit type
Best_scoring_fitType <- ifelse(Median_Absolute_Residual_parametric < Median_Absolute_Residual_local, 'parametric', 'local')
```

Here we create a DESeqDataSet object from the gene-level summarization data, normalize the count data, filter out rows based on unique genes, and then perform differential expression analysis using the best scoring fit type.

```{r}
# Create a DESeqDataSet from the Tximport object
dds <- DESeqDataSetFromTximport(
  txi = TXI.Genes, 
  colData = Samples_metadata,
  rowData = Genes_annotation_metadata[rownames(TXI.Genes$counts),], 
  design = ~ Condition
)

# Estimate size factors
dds <- estimateSizeFactors(dds)

# Filter rows based on unique genes
dds <- dds[unique_genes,]

# Run DESeq with the best scoring fit type
dds <- DESeq(dds, fitType = Best_scoring_fitType)
```

## - Generating VST and RLOG normalised counts

Here we generate variance stabilizing transformation (vst) and rlog normalized counts from our dataset. These normalized counts are then written to CSV files for further analysis.

```{r}
# Generate vst normalised counts
vst <- vst(dds, blind=FALSE)
vst_mat <- as.data.frame(assay(vst)) %>% 
  add_column(GeneSymbol = rowData(vst)$gene_name, .before = colnames(dds)[1]) %>% 
  add_column(GeneBiotype = rowData(vst)$gene_type, .before = colnames(dds)[1]) 

# Write vst normalised counts to CSV
write.csv(vst_mat, 
          file = paste(data_folder, '/RNASeq/InHouse/Counts/Processed_counts/Grouped/DESeq2_vst_normalised_countmat.csv', sep = ''), quote = FALSE, row.names = TRUE)

# Generate rlog normalised counts
rlog <- rlogTransformation(dds, blind=FALSE)
rlog_mat <- as.data.frame(assay(rlog)) %>% 
  add_column(GeneSymbol = rowData(rlog)$gene_name, .before = colnames(dds)[1]) %>% 
  add_column(GeneBiotype = rowData(rlog)$gene_type, .before = colnames(dds)[1]) 

# Write rlog normalised counts to CSV
write.csv(rlog_mat, 
          file = paste(data_folder, '/RNASeq/InHouse/Counts/Processed_counts/Grouped/DESeq2_rlog_normalised_countmat.csv', sep = ''), quote = FALSE, row.names = TRUE)
```

## - Performing PCA analysis

Here we perform Principal Component Analysis (PCA) on the top 500 genes with the highest variance. We then calculate the variance explained by each principal component and the total variance explained by the first three principal components.

```{r}
# Calculate row variances
rv <- rowVars(assay(vst))

# Select the top 500 genes by variance
select <- order(rv, decreasing=TRUE)[seq_len(min(500, length(rv)))]

# Perform PCA on the selected genes
pca <- prcomp(t(assay(vst)[select,]))

# Prepare PCA samples data frame
pca_samples <- as.data.frame(pca$x)
pca_samples$Condition <- colData(dds)[rownames(pca_samples),'Condition']

# Prepare PCA genes data frame
pca_genes <- as.data.frame(pca$rotation)
pca_genes <- add_column(pca_genes, .before = 'PC1', GeneSymbol = rowData(dds)[rownames(pca_genes),'gene_name'])

# Create directory for output
dir.create(path = paste(data_folder, '/RNASeq/InHouse/DESeq2/PCs', sep = ''), showWarnings = FALSE)

# Write PCA samples and genes to CSV
write.csv(pca_samples, file = paste(data_folder, '/RNASeq/InHouse/DESeq2/PCs/DGE_Samples_PCs_from_rlog_normalised_count_mat.csv', sep = ''), quote = FALSE, row.names = TRUE)
write.csv(pca_genes, file = paste(data_folder, '/RNASeq/InHouse/DESeq2/PCs/DGE_Genes_PCs_from_rlog_normalised_count_mat.csv', sep = ''), quote = FALSE, row.names = TRUE)

# Calculate variance explained by each PC
var_explained_df <- data.frame(PC= paste0("PC",1:49), var_explained=(pca$sdev)^2/sum((pca$sdev)^2))

# Write variance explained to CSV
write.csv(var_explained_df, file = paste(data_folder, '/RNASeq/InHouse/DESeq2/PCs/DGE_PC_variance_explained.csv', sep = ''), quote = FALSE, row.names = FALSE)

# Calculate total variance explained by the first three PCs
tot_var_explained <- sum(var_explained_df$var_explained[1:3]) * 100
```

## - Plotting 3d PCs via plotly

This script defines a list of font characteristics to be used in Plotly plots.

```{r}
# Define font characteristics to use on plotly plots
Font_characteristics <- list(
  family = "Helvetica",
  size = 14,
  color = "black"
)
```

### - By condition

This script creates a 3D scatter plot of the first three principal components from the PCA analysis, with points colored by condition. The plot is then customized with a specific layout and saved as a PNG file.

With legend

```{r}
# Create a 3D scatter plot
fig <- plot_ly(
  pca_samples, 
  x = ~PC2, y = ~PC1, z = ~PC3, color = ~Condition, 
  colors = c('BP-CMML' = '#DD3429', 'Control' = '#A4BECE')
) %>% add_markers(size = 12, marker = list(size = 12))

# Customize the layout
fig <- fig %>% layout(
  title = '',
  showlegend = TRUE,
  legend = list(
    title = '', 
    font = Font_characteristics, 
    x = 0.46, # Move the legend more to the left
    y = 0.0, # Move the legend slightly up
    xanchor = 'center',
    yanchor = 'bottom'
  ),
  scene = list(
    bgcolor = "#ffffff",
    camera = list(
      eye = list(x = -1.75, y = 1.85, z = 1.04),
      center = list(x = -0.425, y = 0.35, z = 0) # Move the figure up
    )
  )
)

# Save the figure as a PNG file
save_image(fig, paste(figures_folder, '/Other/DGE_Condition_with_legend.png', sep = ''), width = 2.5 * 300, height = 2.5 * 300, scale = 2)
```

This script creates a 3D scatter plot of the first three principal components from the PCA analysis, with points colored by condition. The plot is then customized with a specific layout, with the legend hidden, and saved as a PNG file.

Without legend

```{r}
# Create a 3D scatter plot
fig <- plot_ly(
  pca_samples, 
  x = ~PC2, y = ~PC1, z = ~PC3, color = ~Condition, 
  colors = c('BP-CMML' = '#DD3429', 'Control' = '#A4BECE')
) %>% add_markers(size = 10, marker = list(size = 10))

# Customize the layout
fig <- fig %>% layout(
  title = '',
  showlegend = FALSE,
  legend = list(
    title = '', 
    font = Font_characteristics, 
    x = 0.45, # Move the legend more to the left
    y = -0.03, # Move the legend slightly up
    xanchor = 'center',
    yanchor = 'bottom'
  ),
  scene = list(
    bgcolor = "#ffffff",
    camera = list(
      eye = list(x = -1.75, y = 1.85, z = 1.04),
      center = list(x = -0.425, y = 0.35, z = 0) # Move the figure up
    )
  )
)

# Save the figure as a PNG file
save_image(fig, paste(figures_folder, '/Other/DGE_Condition_without_legend.png', sep = ''), width = 2.5 * 300, height = 2.5 * 300, scale = 2)
```

### - By ICC classification : Panel C

This script creates a 3D scatter plot of the first three principal components from the PCA analysis, with points colored by ICC classification. The plot is then customized with a specific layout and saved as a PNG file.

With legend

```{r echo=TRUE, fig.align='center', fig.cap='Figure 2C', fig.pos='H', fig.height=8, fig.width=8}
# Prepare PCA samples data frame
pca_samples_ICC <- as.data.frame(pca$x)
pca_samples_ICC$ICC.classification <- colData(dds)[rownames(pca_samples),'ICC.classification']

# Create a 3D scatter plot
fig <- plot_ly(
  pca_samples_ICC, 
  x = ~PC2, y = ~PC1, z = ~PC3, color = ~ICC.classification,
  colors = c(
    'BPDCN' = '#268418',
    'AML with MDS-related cytogenetic abnormalities' = '#B533B8',
    'AML with MDS-related gene mutations' = '#FB84A2',
    'AML with NPM1' = '#1754B8',
    'AML with CEBPA' = '#FFCB7C',
    'AML not otherwise specified' = '#8E3318',
    'Control' = '#A4BECE'
  ),
  marker = list(size = 12)
) 

# Customize the layout
fig <- fig %>% layout(
  title = '',
  showlegend = TRUE,
  legend = list(
    title = '', 
    font = Font_characteristics, 
    x = 0.49, # Move the legend more to the left
    y = -0.03, # Move the legend slightly up
    xanchor = 'center',
    yanchor = 'bottom'
  ),
  scene = list(
    bgcolor = "#ffffff",
    camera = list(
      eye = list(x = -1.75, y = 1.85, z = 1.04),
      center = list(x = -0.425, y = 0.35, z = 0) # Move the figure up
    )
  )
)

# Display the figure
fig

# Save the figure as a PNG file
save_image(fig, paste(figures_folder, '/Fig_02/Panel_C.png', sep = ''), width = 2.5 * 300, height = 2.5 * 300, scale = 2)

# # We also save a PDF copy to be used to assemble a high resolution composite figure for the manuscript (render not included in GitHub repo due to size restriction)
# save_image(fig, paste(figures_folder, '/Fig_02/Panel_C.pdf', sep = ''), width = 2.5 * 300, height = 2.5 * 300, scale = 2)
```

This script creates a 3D scatter plot of the first three principal components from the PCA analysis, with points colored by ICC classification. The plot is then customized with a specific layout, with the legend hidden, and saved as a PNG file.

Without legend

```{r}
# Prepare PCA samples data frame
pca_samples_ICC <- as.data.frame(pca$x)
pca_samples_ICC$ICC.classification <- colData(dds)[rownames(pca_samples),'ICC.classification']

# Create a 3D scatter plot
fig <- plot_ly(
  pca_samples_ICC, 
  x = ~PC2, y = ~PC1, z = ~PC3, color = ~ICC.classification,
  colors = c(
    'BPDCN' = '#268418',
    'AML with MDS-related cytogenetic abnormalities' = '#B533B8',
    'AML with MDS-related gene mutations' = '#FB84A2',
    'AML with NPM1' = '#1754B8',
    'AML with CEBPA' = '#FFCB7C',
    'AML not otherwise specified' = '#8E3318',
    'Control' = '#A4BECE'
  ),
  marker = list(size = 12)
) 

# Customize the layout
fig <- fig %>% layout(
  title = '',
  showlegend = FALSE,
  legend = list(
    title = '', 
    font = Font_characteristics, 
    x = 0.49, # Move the legend more to the left
    y = -0.03, # Move the legend slightly up
    xanchor = 'center',
    yanchor = 'bottom'
  ),
  scene = list(
    bgcolor = "#ffffff",
    camera = list(
      eye = list(x = -1.75, y = 1.85, z = 1.04),
      center = list(x = -0.425, y = 0.35, z = 0) # Move the figure up
    )
  )
)

# Save the figure as a PNG file
save_image(fig, paste(figures_folder, '/Other/DGE_ICC_without_legend.png', sep = ''), width = 3 * 300, height = 3 * 300, scale = 2)
```

### - By WHO classification : Fig S5

This script creates a 3D scatter plot of the first three principal components from the PCA analysis, with points colored by WHO classification. The plot is then customized with a specific layout and saved as a PNG file.

With legend

```{r echo=TRUE, fig.align='center', fig.cap='Figure S5', fig.pos='H', fig.height=8, fig.width=8}
# Prepare PCA samples data frame
pca_samples_WHO <- as.data.frame(pca$x)
pca_samples_WHO$WHO.classification <- colData(dds)[rownames(pca_samples),'WHO.classification']

# Create a 3D scatter plot
fig <- plot_ly(
  pca_samples_WHO, 
  x = ~PC2, y = ~PC1, z = ~PC3, color = ~WHO.classification,
  colors = c(
    'BPDCN' = '#268418',
    'AML myelodysplasia-related' = '#FB84A2',
    'AML with NPM1' = '#1754B8',
    'AML with CEBPA' = '#FFCB7C',
    'AML with other defined genetic alterations' = '#8E3318',
    'Control' = '#A4BECE'
  ),
  marker = list(size = 12)
) 

# Customize the layout
fig <- fig %>% layout(
  title = '',
  showlegend = TRUE,
  legend = list(
    title = '', 
    font = Font_characteristics, 
    x = 0.46, # Move the legend more to the left
    y = 0.0, # Move the legend slightly up
    xanchor = 'center',
    yanchor = 'bottom'
  ),
  scene = list(
    bgcolor = "#ffffff",
    camera = list(
      eye = list(x = -1.75, y = 1.85, z = 1.04),
      center = list(x = -0.425, y = 0.35, z = 0) # Move the figure up
    )
  )
)

# Display the figure
fig

# Save the figure as a PNG file
save_image(fig, paste(figures_folder, '/Supplemental/Fig_S5.png', sep = ''), width = 2.5 * 300, height = 2.5 * 300, scale = 2)

# # We also save a PDF copy to be used to assemble a high resolution composite figure for the manuscript (render not included in GitHub repo due to size restriction)
# save_image(fig, paste(figures_folder, '/Supplemental/Fig_S5.pdf', sep = ''), width = 2.5 * 300, height = 2.5 * 300, scale = 2)
```

This script creates a 3D scatter plot of the first three principal components from the PCA analysis, with points colored by WHO classification. The plot is then customized with a specific layout, with the legend hidden, and saved as a PNG file.

With legend

```{r}
# Prepare PCA samples data frame
pca_samples_WHO <- as.data.frame(pca$x)
pca_samples_WHO$WHO.classification <- colData(dds)[rownames(pca_samples),'WHO.classification']

# Create a 3D scatter plot
fig <- plot_ly(
  pca_samples_WHO, 
  x = ~PC2, y = ~PC1, z = ~PC3, color = ~WHO.classification,
  colors = c(
    'BPDCN' = '#268418',
    'AML myelodysplasia-related' = '#FB84A2',
    'AML with NPM1' = '#1754B8',
    'AML with CEBPA' = '#FFCB7C',
    'AML with other defined genetic alterations' = '#8E3318',
    'Control' = '#A4BECE'
  ),
  marker = list(size = 12)
) 

# Customize the layout
fig <- fig %>% layout(
  title = '',
  showlegend = FALSE,
  legend = list(
    title = '', 
    font = Font_characteristics, 
    x = 0.46, # Move the legend more to the left
    y = 0.0, # Move the legend slightly up
    xanchor = 'center',
    yanchor = 'bottom'
  ),
  scene = list(
    bgcolor = "#ffffff",
    camera = list(
      eye = list(x = -1.75, y = 1.85, z = 1.04),
      center = list(x = -0.425, y = 0.35, z = 0) # Move the figure up
    )
  )
)

# Save the figure as a PNG file
save_image(fig, paste(figures_folder, '/Other/DGE_WHO_with_legend.png', sep = ''), width = 2.5 * 300, height = 2.5 * 300, scale = 2)
```

## - DEGs

Here we load useful gene metadata

```{r}
# Read the transcription factors list
TF_list <- read.csv(
  file = paste(data_folder, '/Resources/RNASeq/Gene_Metadata/Lambert2018_TFs.txt', sep = ''), 
  sep = '\t', 
  header = FALSE
)

# Read the HGNC CD markers list
HGNC_CD_markers_list <- read.csv(
  file = paste(data_folder, '/Resources/RNASeq/Gene_Metadata/HGNC_CD_Markers.csv', sep = '')
)
```

### - BP-CMML vs Control

#### - Evaluating number of significant genes

This script performs differential expression analysis between "BP-CMML" and "Control" conditions, applies three shrinkage estimators for log2 fold changes, and creates MA plots. It also prepares a ggplot scatter plot, colored by significance status, and saves it as a PNG file.

```{r echo=TRUE, fig.align='center', fig.height=4, fig.pos='H', fig.width=7}
# Perform differential expression analysis
res <- results(dds, contrast=c("Condition", "BP-CMML", "Control"), filterFun = ihw)

# Apply different shrinkage estimators for log2 fold changes
resNorm <- lfcShrink(dds, coef="Condition_BP.CMML_vs_Control", res = res, type = 'normal')
resNorm_adj <- as.data.frame(resNorm) %>% filter(padj < 0.05)

resAsh <- lfcShrink(dds, coef="Condition_BP.CMML_vs_Control", res = res, type = 'ashr')
resAsh_adj <- as.data.frame(resAsh) %>% filter(padj < 0.05)

resLFC <- lfcShrink(dds, coef="Condition_BP.CMML_vs_Control", type="apeglm")
resLFC_adj <- as.data.frame(resLFC) %>% filter(padj < 0.05)

# Plot MA plots for each shrinkage estimator
par(mfrow=c(1,3), mar=c(4,4,2,1))
xlim <- c(1,1e5); ylim <- c(-3,3)
plotMA(resNorm, xlim=xlim, ylim=ylim, main="normal")
plotMA(resAsh, xlim=xlim, ylim=ylim, main="ashr")
plotMA(resLFC, xlim=xlim, ylim=ylim, main="apeglm")

# Prepare data for ggplot
resAsh_df_plot <- as.data.frame(resAsh)
resAsh_df_plot[,'Significance'] <- 'Non-significant'
resAsh_df_plot[rownames(resAsh_adj %>% filter(padj <0.05)),'Significance'] <- 'Significant'

# Define colors for the plot
cols <- c('Significant' = '#E58368', 'Non-significant' = '#1d1929')

# Save the plot as a PNG file
png(filename = paste(figures_folder, '/Other/DGE_BP-CMML_vs_Control_resAsh.png', sep = ''), units = 'cm', width = 8.58, height = 12.1, res = 300)

# Create the plot
ggplot(resAsh_df_plot, aes(x = log10(baseMean), y = log2FoldChange, fill = Significance, color = Significance)) + 
  theme_linedraw(base_line_size = 0.2) +
  ggtitle(label = "") + 
  geom_point(inherit.aes = T, shape = 21, alpha = 0.8, size = 1.5) +
  coord_cartesian(ylim = c(-4,4), xlim = c(-0.5,5))  +
  xlab(bquote(~Log[10]~ 'Mean of normalised counts')) + ylab(bquote(~Log[2]~ 'fold change')) +
  theme(legend.position = 'bottom', 
        plot.title = element_text(hjust = 0, face = 'bold', size = 16),
        axis.title.x = element_text(family='Helvetica', size=12, face = 'bold'),
        axis.title.y = element_text(family='Helvetica', size=12, face = 'bold'),
        legend.title = element_text(family='Helvetica', size=12), 
        legend.text = element_text(family='Helvetica', size=10)) +
  scale_colour_manual(
    values = cols,
    aesthetics = c("colour", "fill")
  ) + 
  guides(fill = guide_legend(title = 'Significance status (padj)', 
                              title.position = "top", 
                              title.hjust = 0.5, nrow = 1, override.aes = list(size=3)),
         color = guide_none())

# Close the PNG device
invisible(dev.off())
```

#### - Performing comparison

This script enriches the differential expression results with gene symbol, gene biotype, and flags for transcription factors and CD markers. It then sorts the results by p-value, filters for significant, upregulated, and downregulated genes, and writes each subset to a separate CSV file.

```{r}
# Add gene symbol and gene biotype to the data frame
resAsh_df <- as.data.frame(resAsh) %>% 
  add_column(GeneSymbol = rowData(dds)[rownames(resAsh),'gene_name'], .before = 'baseMean') %>% 
  add_column(GeneBiotype = rowData(dds)[rownames(resAsh),'gene_type'], .before = 'baseMean')

# Add columns for transcription factors and CD markers
resAsh_df$Is_TF <- 'No'
resAsh_df[grep(TRUE, resAsh_df$GeneSymbol %in% TF_list$V1),'Is_TF'] <- 'Yes'

resAsh_df$Is_CD_Marker <- 'No'
resAsh_df[grep(TRUE, resAsh_df$GeneSymbol %in% HGNC_CD_markers_list$Approved.symbol),'Is_CD_Marker'] <- 'Yes'

# Sort by p-value and write all results to a CSV file
res_significant <- resAsh_df %>% arrange(padj)
write.csv(res_significant, 
          file = paste(data_folder, '/RNASeq/InHouse/DESeq2/DEGs_Comparisons/BP-CMML_vs_Control/DGE_BP-CMML_vs_Control_ALL_DEGs_LFC_Ashr.csv', sep = ''), 
          row.names = TRUE, quote = FALSE)

# Filter for significant results, sort by p-value, and write to a CSV file
res_significant <- resAsh_df %>% dplyr::filter(padj < 0.05) %>% dplyr::arrange(padj)
write.csv(res_significant, 
          file = paste(data_folder, '/RNASeq/InHouse/DESeq2/DEGs_Comparisons/BP-CMML_vs_Control/DGE_BP-CMML_vs_Control_padj_significant_DEGs_LFC_Ashr.csv', sep = ''),
          row.names = TRUE, quote = FALSE)

# Filter for upregulated genes, sort by p-value, and write to a CSV file
res_significant_UP <- res_significant %>% dplyr::filter(log2FoldChange >= 0) %>% dplyr::arrange(padj)
write.csv(res_significant_UP, 
          file = paste(data_folder, '/RNASeq/InHouse/DESeq2/DEGs_Comparisons/BP-CMML_vs_Control/DGE_BP-CMML_vs_Control_upregulated_padj_significant_DEGs_LFC_Ashr.csv', sep = ''),
          row.names = TRUE, quote = FALSE)

# Filter for downregulated genes, sort by p-value, and write to a CSV file
res_significant_DOWN <- res_significant %>% dplyr::filter(log2FoldChange < 0) %>% dplyr::arrange(padj)
write.csv(res_significant_DOWN, 
          file = paste(data_folder, '/RNASeq/InHouse/DESeq2/DEGs_Comparisons/BP-CMML_vs_Control/DGE_BP-CMML_vs_Control_downregulated_padj_significant_DEGs_LFC_Ashr.csv', sep = ''),
          row.names = TRUE, quote = FALSE)
```

# 5) Vulcano Plot : Panel D

This script creates a volcano plot of differential expression results, adding log10 transformed p-value and fold change, defining a color scheme, and identifying genes of interest. The plot is then displayed and saved as a PNG file.

```{r}
# Read the CSV file containing DESeq2 results
DESeq2_results <- read.csv(paste(data_folder, '/RNASeq/InHouse/DESeq2/DEGs_Comparisons/BP-CMML_vs_Control/DGE_BP-CMML_vs_Control_ALL_DEGs_LFC_Ashr.csv', sep = ''))
```

```{r echo=TRUE, fig.align='center', fig.cap='Figure 2D', fig.pos='H', fig.height=5.5, fig.width=4.3}
# We rename the results df into another object
genemat_ord <- DESeq2_results

# Add log10 transformed p-value and fold change to the data frame
genemat_ord$Log10pval <- log10(genemat_ord$padj)
genemat_ord$log10FoldChange <- log10(2^genemat_ord$log2FoldChange)

# Define color scheme for the volcano plot
keyvals <- ifelse(
  genemat_ord$log2FoldChange < 0 & genemat_ord$pvalue < 10e-2, '#415384',
  ifelse(genemat_ord$log2FoldChange > 0 & genemat_ord$pvalue < 10e-2, '#C92A1D',
    '#727272'))
keyvals[is.na(keyvals)] <- '#e5e5e5'
names(keyvals)[keyvals == '#C92A1D'] <- 'Upregulated'
names(keyvals)[keyvals == '#727272'] <- 'NS'
names(keyvals)[keyvals == '#415384'] <- 'Downregulated'

# Define genes of interest
BP_Genes <- c('CXCL8', 'KLF2', 'JUNB', 'HOXB9', 'KLF6', 'S100A8', 'S100A9', 'NFKBIA', 'CXCL1', 'SPI1', 'HK3', 'BCL6', 'JUN')  
Control_Genes <- c('CD79A','CD79B', 'VPREB3', 'MYC', 'TOP2B', 'CDK4') 

# Create the volcano plot
plot <- EnhancedVolcano(genemat_ord,
    lab = genemat_ord$GeneSymbol,
    x = 'log2FoldChange',
    y = 'pvalue',
    cutoffLineCol = "grey10",
    cutoffLineWidth = 0,
    selectLab = c(BP_Genes, Control_Genes),
    xlab = bquote(~Log[2]~ 'fold change'),
    pCutoff = 10e-2,
    FCcutoff = 0,
    vlineWidth = 0,
    pointSize = 2.0, 
    xlim = c(-6,6),
    ylim = c(-0.5,12.5),
    hline = 10e-2,
    labSize = 2.0,
    labCol = keyvals[grep(TRUE,genemat_ord$GeneSymbol %in% c(BP_Genes, Control_Genes),)],
    labFace = 'bold',
    caption = NULL,
    boxedLabels = TRUE,
    colAlpha = 4/5,
    legendPosition = 'bottom',
    legendLabSize = 3.5,
    legendIconSize = 1.0,
    drawConnectors = TRUE,
    widthConnectors = 0.5,
    colConnectors = 'black',
    colCustom = keyvals) + ggtitle(label = '', subtitle = '') +
  theme_bw(base_line_size = 0.2) + 
  theme(axis.title.y = element_text(family='Helvetica', size = 12, face = 'bold'),
        axis.title.x = element_text(family='Helvetica', size = 12, face = 'bold'), 
        plot.title = element_text(family='Helvetica', size = 12, face = 'bold'), 
        legend.position = 'bottom') + 
  guides(color = guide_legend(title = ''))

print(plot)

# Save the plot to a PNG file
png(filename = paste(figures_folder, '/Fig_02/Panel_D.png', sep = ''), units = 'in', width = 4.3, height = 5.5, res = 300)
print(plot)
invisible(dev.off())

# # We also save a PDF copy to be used to assemble a high resolution composite figure for the manuscript (render not included in GitHub repo due to size restriction)
# pdf(file = paste(figures_folder, '/Fig_02/Panel_D.pdf', sep = ''), width = 4.3, height = 5.5)
# print(plot)
# invisible(dev.off())
```

# 6) Heatmap : Panel E

This script reads a CSV file containing upregulated genes in BP-CMML, filters for protein-coding genes, and selects the top 30 genes based on adjusted p-value.

```{r}
# Read the CSV file containing upregulated genes in BP-CMML
UP_in_BP_CMML <- read.csv(paste(data_folder, '/RNASeq/InHouse/DESeq2/DEGs_Comparisons/BP-CMML_vs_Control/DGE_BP-CMML_vs_Control_upregulated_padj_significant_DEGs_LFC_Ashr.csv', sep = ''), row.names = 'X')

# Filter for protein coding genes
UP_in_BP_CMML <- UP_in_BP_CMML %>% filter(GeneBiotype == 'protein_coding')

# Select top 30 genes based on adjusted p-value
BP_CMML_genes <- (UP_in_BP_CMML %>% arrange(padj))$GeneSymbol[1:30]
```

This script reads a CSV file containing upregulated genes in controls, filters for protein-coding genes, and selects the top 30 genes based on adjusted p-value.

```{r}
# Read the CSV file containing upregulated genes in healthy control
UP_in_healthy <- read.csv(paste(data_folder, '/RNASeq/InHouse/DESeq2/DEGs_Comparisons/BP-CMML_vs_Control/DGE_BP-CMML_vs_Control_downregulated_padj_significant_DEGs_LFC_Ashr.csv', sep = ''), row.names = 'X')

# Filter for protein coding genes
UP_in_healthy <- UP_in_healthy %>% filter(GeneBiotype == 'protein_coding')

# Select top 30 genes based on adjusted p-value
Healthy_genes <- ((UP_in_healthy %>% arrange(padj))$GeneSymbol[1:30])

# Combine the selected genes from both groups
genes_to_keep <- c(BP_CMML_genes, Healthy_genes)
```

This script processes VST normalised counts, selects and scales specific genes, and creates a heatmap of the scaled expression data using the ComplexHeatmap package. The heatmap is then displayed and saved as a PNG file.

```{r echo=TRUE, fig.align='center', fig.cap='Figure 2E', fig.pos='H', fig.height=4.724412, fig.width=6.141732}
# Read the CSV file containing VST normalised counts
vst_results <- read.csv(paste(data_folder, '/RNASeq/InHouse/Counts/Processed_counts/Grouped/DESeq2_vst_normalised_countmat.csv', sep = ''), row.names = 'X')

# Replace 'X' in column names with ''
colnames(vst_results) <- str_replace_all(colnames(vst_results), pattern = 'X', replacement = '')

# Filter for selected genes
vst_results_to_keep <- vst_results[grep(TRUE,vst_results$GeneSymbol %in% genes_to_keep),]

# Set row names and remove unnecessary columns
rownames(vst_results_to_keep) <- vst_results_to_keep$GeneSymbol
vst_results_to_keep$GeneSymbol <- NULL
vst_results_to_keep$GeneBiotype <- NULL

# Convert the data frame to a matrix
vst_results_to_keep_mat <- as.matrix(vst_results_to_keep)

# Select the top 30 and bottom 30 genes
vst_results_to_keep_mat_top30bot30 <- vst_results_to_keep_mat[genes_to_keep,]

# Scale the data
scaled_genemat_ord_GeneSymbol <- t(scale(t(vst_results_to_keep_mat_top30bot30)))[,]
scaled_genemat_ord_GeneSymbol <- t(scaled_genemat_ord_GeneSymbol)

# Create data frames for gene and phenotype identity
gene_identity <- data.frame(row.names = genes_to_keep)
gene_identity[BP_CMML_genes,'Group'] <- 'Up in BP CMML'
gene_identity[Healthy_genes,'Group'] <- 'Up in Control'
gene_identity$Group <- factor(gene_identity$Group, levels = c('Up in Control', 'Up in BP CMML'))

Phenotype_identity <- data.frame(row.names = colnames(dds))
Phenotype_identity$Condition <- dds$Condition
Phenotype_identity[rownames(Phenotype_identity %>% filter(Condition == 'BP-CMML')),'Condition'] <- 'BP-CMML'
Phenotype_identity$Condition <- factor(Phenotype_identity$Condition, levels = c('Control', 'BP-CMML'))

# Define color scheme for the heatmap
colors_annotation <-  list(Condition = c('Control' = '#A4BECE', 'BP-CMML' = '#DD3429'))

# Create row annotation for the heatmap
ha <- rowAnnotation(df=Phenotype_identity, col = colors_annotation, 
                    gp = gpar(lwd =0.5, col = 'white'),
                    simple_anno_size = unit(0.25, 'cm'),
                    show_annotation_name = F, show_legend = FALSE,
                    annotation_legend_param = list(Condition = list(direction = "horizontal")))

# Define color scheme for the heatmap
breaks_val <- seq(from = -1.5, to = 2, length.out = 13)
col_heatmap_guide <- colorRamp2(breaks = breaks_val,colors = rev(brew_mix))

# Create the heatmap
Heatmap_genes <- Heatmap(scaled_genemat_ord_GeneSymbol, name = 'Scaled\nExpression',
                         col = col_heatmap_guide,
                         show_row_names = FALSE, 
                         show_column_names = TRUE,
                         cluster_columns = TRUE,
                         cluster_rows = TRUE, 
                         column_split = gene_identity$Group,
                         row_split = Phenotype_identity$Condition,
                         border = TRUE,
                         cluster_row_slices = F, 
                         cluster_column_slices = F, 
                         row_gap = unit(0.05, 'cm'),
                         column_gap = unit(0.05, 'cm'),
                         show_column_dend = FALSE, 
                         row_dend_side = 'right',
                         column_names_side = 'bottom',
                         use_raster = FALSE, 
                         rect_gp = gpar(col = "black", lwd = 0.05),
                         raster_by_magick = TRUE, 
                         left_annotation = ha,
                         row_title_gp = gpar(fontsize = 0, angle=45),
                         row_names_gp = gpar(fontsize = 7, hjust=0),
                         column_title_gp = gpar(fontsize = 12),
                         column_names_gp = gpar(fontsize = 4, hjust=0),
                         show_heatmap_legend = F,
                         heatmap_legend_param = list(legend_direction = "horizontal", legend_width = unit(5, "cm")))

ComplexHeatmap::draw(Heatmap_genes, heatmap_legend_side = "bottom", annotation_legend_side = "bottom")

# Save the heatmap to a PNG file
png(filename = paste(figures_folder, '/Fig_02/Panel_E.png', sep = ''), height = 10, width = 13, units = 'cm',res = 300)
ComplexHeatmap::draw(Heatmap_genes, heatmap_legend_side = "bottom", annotation_legend_side = "bottom")
invisible(dev.off())

# # We also save a PDF copy to be used to assemble a high resolution composite figure for the manuscript (render not included in GitHub repo due to size restriction)
# pdf(file = paste(figures_folder, '/Fig_02/Panel_E.pdf', sep = ''), width = 5.11811 , height = 3.93701)
# ComplexHeatmap::draw(Heatmap_genes, heatmap_legend_side = "bottom", annotation_legend_side = "bottom")
# invisible(dev.off())

###

# We will also save a version of this figure including the scale, previously omitted to maintain more easily the figure proportions

# Create the heatmap
Heatmap_genes <- Heatmap(scaled_genemat_ord_GeneSymbol, name = 'Scaled\nExpression',
                         col = col_heatmap_guide,
                         show_row_names = FALSE, 
                         show_column_names = TRUE,
                         cluster_columns = TRUE,
                         cluster_rows = TRUE, 
                         column_split = gene_identity$Group,
                         row_split = Phenotype_identity$Condition,
                         border = TRUE,
                         cluster_row_slices = F, 
                         cluster_column_slices = F, 
                         row_gap = unit(0.05, 'cm'),
                         column_gap = unit(0.05, 'cm'),
                         show_column_dend = FALSE, 
                         row_dend_side = 'right',
                         column_names_side = 'bottom',
                         use_raster = FALSE, 
                         rect_gp = gpar(col = "black", lwd = 0.05),
                         raster_by_magick = TRUE, 
                         left_annotation = ha,
                         row_title_gp = gpar(fontsize = 0, angle=45),
                         row_names_gp = gpar(fontsize = 7, hjust=0),
                         column_title_gp = gpar(fontsize = 12),
                         column_names_gp = gpar(fontsize = 4, hjust=0),
                         show_heatmap_legend = T,
                         heatmap_legend_param = list(legend_direction = "horizontal", legend_width = unit(5, "cm")))

# Save the heatmap to a PNG file
png(filename = paste(figures_folder, '/Other/Panel_E_with_legend.png', sep = ''), height = 10, width = 13, units = 'cm',res = 300)
ComplexHeatmap::draw(Heatmap_genes, heatmap_legend_side = "bottom", annotation_legend_side = "bottom")
invisible(dev.off())

# # We also save a PDF copy to be used to assemble a high resolution composite figure for the manuscript (render not included in GitHub repo due to size restriction)
# pdf(file = paste(figures_folder, '/Other/Panel_E_with_legend.pdf', sep = ''), width = 5.11811 , height = 3.93701)
# ComplexHeatmap::draw(Heatmap_genes, heatmap_legend_side = "bottom", annotation_legend_side = "bottom")
# invisible(dev.off())
```

# 7) Gene Dispersion : Panel F

This script creates directories, gets sample IDs, prepares TXI.Genes and DESeqDataSet for Control and BP-CMML conditions, creates a data frame with dispersion values, and writes the data frame to a CSV file. Metrics identified were used as input in GraphPad and illustrated (see under ***GraphPad/Fig_02/Panel_F.pzfx***)..

```{r}
# Create directories
dir.create(path = paste(data_folder, '/RNASeq/InHouse/DESeq2/Other', sep = ''), showWarnings = F)
dir.create(path = paste(data_folder, '/RNASeq/InHouse/DESeq2/Other/Gene_Dispersion', sep = ''), showWarnings = F)
dir.create(path = paste(data_folder, '/RNASeq/InHouse/DESeq2/Other/Gene_Dispersion/BP-CMML_vs_Control', sep = ''), showWarnings = F)

# Get sample IDs
Control_samples <- Samples_metadata %>% mutate(Sample.ID = rownames(Samples_metadata)) %>% filter(Condition == 'Control') %>% .$Sample.ID
BPCMML_samples <- Samples_metadata %>% mutate(Sample.ID = rownames(Samples_metadata)) %>% filter(Condition == 'BP-CMML') %>% .$Sample.ID

# Prepare TXI.Genes for Control
TXI.Genes_Control <- TXI.Genes
TXI.Genes_Control$abundance <- TXI.Genes_Control$abundance[,Control_samples]
TXI.Genes_Control$counts <- TXI.Genes_Control$counts[,Control_samples]
TXI.Genes_Control$length <- TXI.Genes_Control$length[,Control_samples]

# Prepare DESeqDataSet for Control
dds_control <- DESeqDataSetFromTximport(txi = TXI.Genes_Control, colData = Samples_metadata[Control_samples,], rowData= Genes_annotation_metadata[rownames(TXI.Genes_Control$counts),], design = ~1)
dds_control <- estimateSizeFactors(dds_control)
dds_control <- dds_control[unique_genes,]
dds_control <- DESeq(dds_control, fitType = "local")

# Prepare TXI.Genes for BP-CMML
TXI.Genes_BPCMML <- TXI.Genes
TXI.Genes_BPCMML$abundance <- TXI.Genes_BPCMML$abundance[,BPCMML_samples]
TXI.Genes_BPCMML$counts <- TXI.Genes_BPCMML$counts[,BPCMML_samples]
TXI.Genes_BPCMML$length <- TXI.Genes_BPCMML$length[,BPCMML_samples]

# Prepare DESeqDataSet for BP-CMML
dds_BPCMML <- DESeqDataSetFromTximport(txi = TXI.Genes_BPCMML, colData = Samples_metadata[BPCMML_samples,], rowData= Genes_annotation_metadata[rownames(TXI.Genes_BPCMML$counts),], design = ~1)
dds_BPCMML <- estimateSizeFactors(dds_BPCMML)
dds_BPCMML <- dds_BPCMML[unique_genes,]
dds_BPCMML <- DESeq(dds_BPCMML, fitType = "local")

# Create data frame with dispersion values
df <- data.frame(row.names = rownames(rowData(dds)))
df$Disp_Control <- rowData(dds_control)[,'dispersion']
df$Disp_BPCMML <- rowData(dds_BPCMML)[,'dispersion']

# Write to CSV
write.csv(df, file = paste(data_folder, '/RNASeq/InHouse/DESeq2/Other/Gene_Dispersion/BP-CMML_vs_Control/Gene_Dispersion_per_condition.csv', sep = ''), row.names = T)
```
